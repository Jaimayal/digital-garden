<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Volver a la Nota Principal
1. From Programming to Software Engineering Este capitulo en particular busca definir de forma clara los conceptos de programador, desarrollador de software e ingeniero de software."><title>The essentials of modern software engineering: Free the practices from the method prisons - Notes</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://jaimayal.github.io/digital-garden//icon.png><link href=https://jaimayal.github.io/digital-garden/styles.b3e1e36b0403ac565c9392b3e23ef3b6.min.css rel=stylesheet><link href=https://jaimayal.github.io/digital-garden/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://jaimayal.github.io/digital-garden/js/darkmode.5d7889c2be4adb5d3002ee0ab22c62aa.min.js></script>
<script src=https://jaimayal.github.io/digital-garden/js/util.9825137f5e7825e8553c68ce39ac9e44.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://jaimayal.github.io/digital-garden/js/popover.abe6a51cc7138c5dff00f151dd627ad1.min.js></script>
<script src=https://jaimayal.github.io/digital-garden/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://jaimayal.github.io/digital-garden/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://jaimayal.github.io/digital-garden/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://jaimayal.github.io/digital-garden/",fetchData=Promise.all([fetch("https://jaimayal.github.io/digital-garden/indices/linkIndex.d1066132975f9a1862337adba8f59672.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://jaimayal.github.io/digital-garden/indices/contentIndex.f264daa16702b70632516b00f58af418.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://jaimayal.github.io/digital-garden",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://jaimayal.github.io/digital-garden",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.7})}},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/jaimayal.github.io\/digital-garden\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://jaimayal.github.io/digital-garden/js/full-text-search.24827f874defbbc6d529926cbfcfb493.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://jaimayal.github.io/digital-garden/>ðŸŒ± Digital Garden</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>The essentials of modern software engineering: Free the practices from the method prisons - Notes</h1><p class=meta>Last updated
Sep 18, 2022
<a href=https://github.com/jaimayal/digital-garden/tree/main/content/reference/The%20essentials%20of%20modern%20software%20engineering%20Free%20the%20practices%20from%20the%20method%20prisons/notas.md rel=noopener>Edit Source</a></p><ul class=tags><li><a href=https://jaimayal.github.io/digital-garden/tags/softwaredev/>Softwaredev</a></li></ul><aside class=mainTOC><details open><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#1-from-programming-to-software-engineering>1. From Programming to Software Engineering</a><ol><li><a href=#11-beginning-with-programming>1.1 Beginning with Programming</a></li><li><a href=#12-programming-is-not-software-engineering>1.2 Programming is Not Software Engineering</a></li><li><a href=#13-from-internship-to-industry>1.3 From Internship to Industry</a></li><li><a href=#14-journey-into-the-software-engineering-profession>1.4 Journey into the Software Engineering Profession</a></li></ol></li><li><a href=#resumen---from-programming-to-software-engineering>Resumen - From Programming to Software Engineering</a></li><li><a href=#2-software-engineering-methods-and-practices>2. Software Engineering Methods and Practices</a><ol><li><a href=#21-software-engineering-challenges>2.1 Software Engineering Challenges</a></li><li><a href=#22-the-rise-of-software-engineering-methods-and-practices>2.2 The Rise of Software Engineering Methods and Practices</a></li><li><a href=#23-the-semat-initiative>2.3 The SEMAT Initiative</a></li><li><a href=#24-essence-the-omg-standard>2.4 Essence: The OMG Standard</a></li></ol></li><li><a href=#resumen---software-engineering-methods-and-practices>Resumen - Software Engineering Methods and Practices</a><ol><li><a href=#ciclo-de-vida>Ciclo de Vida</a></li><li><a href=#tecnicas>Tecnicas</a></li><li><a href=#agiles>Agiles</a></li><li><a href=#escencia-y-semat>Escencia y SEMAT</a></li></ol></li></ol></nav></details></aside><p><em><a rel=noopener class="internal-link broken" data-src=es/reference/The%20essentials%20of%20modern%20software%20engineering%20Free%20the%20practices%20from%20the%20method%20prisons/main>Volver a la Nota Principal</a></em></p><a href=#1-from-programming-to-software-engineering><h2 id=1-from-programming-to-software-engineering><span class=hanchor arialabel=Anchor># </span>1. From Programming to Software Engineering</h2></a><p>Este capitulo en particular busca definir de forma clara los conceptos de programador, desarrollador de software e ingeniero de software. Nos dara sus diferencias y semejanzas para poder distinguir y transicionar de una posicion a otra.</p><a href=#11-beginning-with-programming><h3 id=11-beginning-with-programming><span class=hanchor arialabel=Anchor># </span>1.1 Beginning with Programming</h3></a><p><strong>Programacion</strong> se considera como sinonimo de <em>implementacion</em> o <em>codificacion</em>, este proceso no incluye ningun tipo de debug, o pruebas, se limita a la escritura del codigo fuente de una aplicacion.</p><p><strong>Desarrollo de Software</strong> es una actividad que integra la <em>toma de requisitos</em>, el <em>diseÃ±o</em>, la <em>implementacion</em> (programacion), las <em>pruebas</em> y el <em>deployment</em>.</p><p><strong>Ingenieria de Software</strong> es unir conceptos de la disciplina de <em>ingenieria</em> con el <em>desarrollo de software</em>, de modo que se obtengan todas las ventajas de ella y se agreguen a un proceso ya establecido.</p><p>Para esta parte, en la jornada de Smith el ya ha aprendido todo lo basico de programacion, desde programacion estructurada hasta programacion orientada a objetos y un par de lenguajes (Java y JavaScript).</p><a href=#12-programming-is-not-software-engineering><h3 id=12-programming-is-not-software-engineering><span class=hanchor arialabel=Anchor># </span>1.2 Programming is Not Software Engineering</h3></a><p>Hacking y Desarrollo profesional son dos cosas muy distintas y son dos acercamientos muy distintos que podemos tener a la programacion de un software.</p><p><strong>Desarrollo Profesional</strong> es cuando escribes el codigo de forma que refleja tu analisis y pensamiento para resolver determinado problema, de esta manera, entiendes el codigo que acabas de escribir.</p><p><strong>Hacking</strong> es cuando intentas codigo casi al azar hasta lograr alcanzar el objetivo que tienes sin siquiera saber como funciona.</p><p>El Desarrollo Profesional es una parte vital de la Ingenieria del Software, adicionalmente, esta ultima tiene muchas mas actividades relacionadas que no son solo escribir codigo.</p><p>Para esta parte, Smith ya ha trabajado en un proyecto con compaÃ±eros y se dio cuenta que programar solo forma una parte del ciclo, llego a la conclusion de que se tienen que tener unos requisitos, se llega a un consenso mediante lluvia de ideas, se desarrolla y finalmente se mantiene, algo todavia muy alejado de la realidad.</p><a href=#13-from-internship-to-industry><h3 id=13-from-internship-to-industry><span class=hanchor arialabel=Anchor># </span>1.3 From Internship to Industry</h3></a><p>Usualmente, en un equipo de desarrollo podemos encontra dos tipos de personas:</p><ul><li>Aquellas que dictan y solicitan lo que el software debe hacer</li><li>Aquellas que lo codifican, prueban y entregan</li></ul><p>La comunicacion entre Managers o personas con dominio sobre el problema del que se trata (primer grupo) hablan una jerga muy particular, usualmente, esta varia de empresa a empresa debido al dominio de la misma.</p><p>Como leccion, para ser un buen ingeniero de software, no solo debes conocer la forma de desarrollo de tu equipo sino tambien el dominio del problema de tu empresa.</p><p>Usualmente el trabajo en una empresa no se va a tratar de escribir codigo nuevo, si no de mantener y revisar el ya existente, ademas, para asegurarse de que no rompiste nada siempre hay que realizar testing a todos los cambios que hagas.</p><p>Mientras mas vas avanzando en los puestos de desarrollo, mayor es la cantidad de Sr (Seniority) que se te atribuye, conforme esta crece lo hacen proporcionalmente tus responsabilidades de liderazgo y comunicacion con los Stakeholders (Empresarios, jefes, CEOs, etc).</p><p>Una buena comunicacion con los Stakeholders se basa en llegar a terminos y practicas comunes de modo que permitan el flujo de trabajo de todos los miembros del equipo, basandose en unos buenos valores (en tiempo, forma y de alta calidad). Engloban cosas como revisiones, correccion de bugs, recibimiento de feedback y otras habilidades para alcanzar esas metas particulares que ambos tienen en mente.</p><a href=#14-journey-into-the-software-engineering-profession><h3 id=14-journey-into-the-software-engineering-profession><span class=hanchor arialabel=Anchor># </span>1.4 Journey into the Software Engineering Profession</h3></a><p>La experiencia en la universidad solo son los fundamentos de desarrollo pero carece de los siguientes aspectos:</p><ul><li>No se realiza mantenimiento al codigo</li><li>No se implementan nuevas caracteristicas</li><li>No se escala para el uso de mas usuarios</li></ul><p>Ignorando las grandes compaÃ±ias de tecnologia como Facebook, Amazon, Twitter, Netflix, Shopify, etc. Una compaÃ±ia promedio seguramente buscara tener un departamento de desarrollo para satisfacer una necesidad suya, de sus clientes o de sus usuarios finales.</p><p>Un joven estudiante seguramente estara mas interesado en conocer las tecnologias, las computadoras, las redes con las que se trabaja y no tanto con el dominio (negocio) de la empresa para la que va a trabajar, por tanto, no le interesaran las practicas de desarrollo, los valores u otras cosas relacionadas.</p><p>Los equipos del trabajo son la unidad minima con la que se construye un software, si es un software grande, usualmente distintos equipos trabajaran de forma sincronizada en distintas funcionalidades.</p><p>Para desarrollar un software primero necesitamos los requisitos, saber que es lo que se necesita hacer y revisar con los expertos para corregir cualquier mal funcion o recibir feedback respecto a las ya existentes.</p><p>Hay una disciplina de la ingenieria dedicada exclusivamente a los requisitos, su interpretacion, como se obtienen y como se piensa y razona sobre ellos, su nombre es <em>requierements engineering</em>.</p><p>Existe otra disciplina que conforma el <strong>diseÃ±o</strong> del software, se refiere a la calidad que se coloca en el codigo de modo que le permita ser mantenible, reusable, escalable, etc.</p><p>Un diseÃ±o se puede estudiar de dos formas:</p><ul><li>Viendo las clases, modulos, funciones, unidades del codigo en cuestion.</li><li>Utilizando una herramienta de diagramas que te permita modelar tu codigo.</li></ul><p><em>Me parecio interesante como hace mencion del diseÃ±o como la disciplina en la cual se le da forma al codigo para que sea de calidad / mantenible, es decir, que sea facil de escalar, de entender, de probar, de cambiar, es como lo que nos comentaba el profesor Luis en el curso de Recurrencia en el Desarrollo de Software. Lo que se busca finalmente es REDUCIR SU COMPLEJIDAD</em>.</p><p>No son las unicas tareas que debe hacer un ingeniero de software, usualmente se agregan dos que son las <strong>pruebas</strong> y el <strong>despliegue</strong>.</p><p>Se podria decir entonces que la Ingenieria del Software es una disciplina replicable y evolucionable, que busca convertir las necesidades de un cliente en requisitos claros, para que desarrolladores con las habilidades sociales como para comunicarse y escribir codigo de calidad (es decir, en modulos que tengan alta mantenibilidad) lo diseÃ±en, lo desarrollen, lo prueben, reciban feedback, lo corrigan y repitan, hasta lograr el producto deseado por los clientes, en ese momento, ocurrira el despliegue.</p><a href=#resumen---from-programming-to-software-engineering><h2 id=resumen---from-programming-to-software-engineering><span class=hanchor arialabel=Anchor># </span>Resumen - From Programming to Software Engineering</h2></a><p>Programar es muy diferente a desarrollar software, de hecho, la programacion es solo una actividad del desarrollo, un ciclo completo del desarrollo de Software se veria asi:</p><ul><li>Disciplina de Requisitos</li><li>Disciplina de Analisis y DiseÃ±o</li><li>Disciplina de Programacion</li><li>Disciplina de Pruebas</li><li>Disciplina de Despliegue</li></ul><p>La Ingenieria del Software no es mas que la integracion de discplinas de la ingenieria al proceso del desarrollo de software, esto con el fin de que sea una actividad replicable, mejorable, organizada y facil de llevar.</p><p>Existe una diferencia muy clara entre <strong>desarrollo profesional</strong> y el <strong>&ldquo;hacking&rdquo;</strong>, la ultima se refiere a cuando se utiliza codigo de forma casi aleatoria sin saber lo que hace hasta lograr obtener el resultado esperado, la primera ocurre cuando analisas y escribes el codigo de forma clara, de modo que, cuando lo integres con el resto del codigo sepas que es lo que esta haciendo.</p><p>El conocimiento de la jerga que se encuentra en el dominio de la empresa para la que trabajas es fundamental para comunicarse de forma efectiva con los expertos.</p><p>Conforme se avanza en la industria del desarrollo del Software (Es decir, se incrementa el Seniority) las habilidades de comunicacion juegan un rol cada vez mas importante. Entre ellas podemos decir que resaltan el liderazgo de un equipo y la comunicacion con los Stakeholders (o expertos) para la toma de requisitos.</p><p>La toma de requisitos puede ocurrir de distintas formas, ya sea que se te pida copiar a otro software, que se te de un papel o una simple idea. De hecho es tan cambiante e interesante que hay una disciplina de la ingenieria dedicada a ello, <em>requierements engineering</em>.</p><p>Debido a que los requisitos se encuentran en constante cambio, el diseÃ±o del codigo del software debe de ser muy modular, con piezas que sean altamente mantenibles (faciles de entender, reusables, probables y cambiables).</p><p>Las pruebas toman un rol extremadamente importante, escribirlas garantiza que aunque tu te vayas de la empresa en un futuro tu unidad de trabajo pueda seguir siendo matenible sin problemas.</p><p>El despliegue usualmente no es llevado acabo por desarrolladores, sin embargo, puede serlo, este proceso es cuando se coloca el software en un servidor o en produccion para que los usuarios finales puedan hacer uso de el.</p><a href=#2-software-engineering-methods-and-practices><h2 id=2-software-engineering-methods-and-practices><span class=hanchor arialabel=Anchor># </span>2. Software Engineering Methods and Practices</h2></a><p>Este capitulo busca introducir a la estandarizacion de las practicas y metodos utilizados en el desarrollo de software. Principalmente se abordaran tres temas:</p><ul><li>Problemas que enfrenta nuestra industria</li><li>Metodologias de Desarrollo en los ultimos 40 aÃ±os</li><li>Motivaciones para la esencia</li></ul><a href=#21-software-engineering-challenges><h3 id=21-software-engineering-challenges><span class=hanchor arialabel=Anchor># </span>2.1 Software Engineering Challenges</h3></a><p>Existen retos en la industria, principalmente los podemos ver en noticias de sucesos que ocurren respecto a fallos en el Software que se encuentra detras de cosas tan importantes como sistemas de seguridad o sistemas financieros.</p><p>Errores como estos pueden tratar ser prevenidos pero nunca nunca sera completamente cierto que dejaran de ocurrir o que podran ser evitados del todo.</p><a href=#22-the-rise-of-software-engineering-methods-and-practices><h3 id=22-the-rise-of-software-engineering-methods-and-practices><span class=hanchor arialabel=Anchor># </span>2.2 The Rise of Software Engineering Methods and Practices</h3></a><p>Esta claro que la &ldquo;Crisis del Software&rdquo; no solo ocurrio por mala programacion, principalmente porque como ya vimos, un desarrollo de software no solo ocurre con programar y ya, tiene sus requisitos, comunicacion, equipos, pruebas, etc.</p><p>A traves de la historia han surgido metodos de desarrollo que han servido para cumplir distintas necesidades. A las partes comunes entre un metodo y otro se le ha estandarizado como <strong>practicas</strong>, estas definen la esencia de las metodologias de desarrollo.</p><p>Estas practicas pueden ser de distintos tipos para el equipo (ambiente agradable, de facil codificacion, de facil colaboracion), para el cliente (buena toma de requisitos, conocimiento del dominio, conocimiento de la jerga) entre otras.</p><a href=#221-there-are-lifecycles><h4 id=221-there-are-lifecycles><span class=hanchor arialabel=Anchor># </span>2.2.1 There Are Lifecycles</h4></a><p><em>Al estar leyendo sobre la introduccion a la metodologia de cascada note una similitud con lo que estamos viendo en Informatica V. En la clase vimos el proceso de Planificar, Hacer, Verificar y Actuar, en la metodologia de cascada tenemos Requisitar, DiseÃ±ar, Implementar y Verificar.</em></p><p>Hubieron dos grandes cambios en las metodologias de la industria del Software.</p><p>La primera fue la introduccion de la metodologia de cascada, esta concebia al desarrollo de software como un proceso lineal en el cual se llevaba acabo la toma de requisitos, el analisis y diseÃ±o, la coficiacion y las pruebas. Era muy malo seguirla a rajatabla debido a que muchas veces en un proyecto de software los requisitos desde un inicio no llegan a estar completamente claros. Por tanto, al momento de probar y darle a tus usuarios el software se denota que le falta muchisima funcionalidad, le sobran muchisimas cosas cuando parecia que estabas por terminar!</p><p>La segunda fue la introduccion de iteraciones, esta dictaba que solo se tomaban pocos requisitos, se analizaba, se programaba y se probaba, de modo que, en lapsos de tiempo mucho mas cortos se pueda recibir feedback del usuario final para saber como mejorar el producto, y asi avanzar de forma iterativa</p><p>Esta ultima fue tomada por metodologias agiles y la metodologia de gestion mas popular hoy en dia es SCRUM, combinada con Agile (iteraciones) forma una potente forma de desarrollar software</p><a href=#222-there-are-technical-practices><h4 id=222-there-are-technical-practices><span class=hanchor arialabel=Anchor># </span>2.2.2 There Are Technical Practices</h4></a><p>Desde los inicios del software, los problemas con la toma de requisitos, el analisis, las pruebas, comunicacion, manejo de proyectos y liderazgo han sido recurrentes. Sin embargo, antes estos problemas eran atacados desde la perspectiva del codigo y no se le prestaba mucha atencion a lo demas. Hoy en dia, nos enfrentamos a todos los retos de forma conjunta y constante, es por eso, que surgieron nuevas metodologias para tener un marco de trabajo sobre el cual estructurar los proyectos.</p><a href=#2221-the-structured-methods-era><h5 id=2221-the-structured-methods-era><span class=hanchor arialabel=Anchor># </span>2.2.2.1 The Structured Methods Era</h5></a><p>El desarrollo se basaba en metodologias estructuradas, esto quiere decir que se percibian las funciones por un lado y los datos por otro. Surgieron marcos de trabajo y grandes proyectos bajo esta metodologia, sin embargo, al mantenimiento y la escalabilidad del software era casi nula, eso fue lo que acabo con esta era.</p><a href=#2222-the-component-methods-era><h5 id=2222-the-component-methods-era><span class=hanchor arialabel=Anchor># </span>2.2.2.2 The Component Methods Era</h5></a><p>El desarrollo se basaba en metodologias por <em>componentes</em> (modulos, clases, objetos, espacios, unidades, etc) principalmente influenciado por el paradigma orientado a objetos que concebia a los datos e informacion por igual. Surgieron muchos enfoques, hasta que en 1990 se unifico el modelado creando el UML (Unified Modeling Language) y se impulso la metodologia RUP (Rational Unified Process), todas las demas murieron.</p><p>Esta era culmino con la creacion de practicas mas avanzadas como las arquitecturas EA - Enterprise Architecture, SOA Service-Oriented Architecture, PLA - Product-Line Architecture. Hoy en dia las podemos ver con Web Development, Cloud Services, Mobile Development, etc.</p><a href=#2223-the-agile-methods-era><h5 id=2223-the-agile-methods-era><span class=hanchor arialabel=Anchor># </span>2.2.2.3 The Agile Methods Era</h5></a><p>El desarrollo conservo los conceptos traidos desde la era anterior, se estandarizo practicas tecnicas y humanas para crear un marco de trabajo que funcionara sobre la metodologia iterativa, integro la idea de la mejora continua (Esto lo vemos con la creacion de backlogs, refactoring, TDD, etc) para continuar mejorando el desarrollo agil.</p><a href=#2224-there-are-people-practices><h5 id=2224-there-are-people-practices><span class=hanchor arialabel=Anchor># </span>2.2.2.4 There Are People Practices</h5></a><p>Anterior a las metodologias agiles no se le tomaba importancia al capital humano, se consideraba que eso era parte de R.H. Sin embargo, tras la llegada de Agile al mundo de desarrollo se pasaron a crear nuevas practicas (Como el pair programming, las daily standups) que se enfocaban mas en darle las herramientas a los desarrolladores para que pudieran trabajar de forma continua. Es por eso que es el paradigma mas popular hoy en dia.</p><a href=#223-consequences><h4 id=223-consequences><span class=hanchor arialabel=Anchor># </span>2.2.3 Consequences</h4></a><p>Ya vimos todos los cambios que ocurrieron entre paradigmas, ciclos de vida. los proyectos, por que scrum es popular pero hay que pensar en las consecuencias que ha traido (y probablemente traera) hacer cambios por cambiar:</p><ul><li>Necesidad de nueva capacitacion. Principalmente debido al cambio de vocabulario, de ideologia, de forma de desarrollar, de metodologias, de cambios en el codigo, etc, etc.</li><li>Creacion de 10000 metodologias bajo la misma idea, monolitos. Cada autor busca que te cases con su &ldquo;forma definitiva de desarrollar software basada en agiles&rdquo; sin tomar en cuenta las malas ideas que tienen ni nada</li><li>Innovaciones incitan cambios. Que bajo cada innovacion que se haga en la industria se necesitaran cambios y dependiendo la metodologia sera de mayor o menor perdida para todos.</li></ul><p>Â¿Todo esto en que concluye? En perdidas de tiempo, dinero, capital de todos los tipos, tiranias de gobierno en metodologias, etc. En una industria tan grande como el desarrollo de software esto es imperdonable. Para solucionar estos problemas esque se ha la organizacion del SEMAT (Software Engineering Method And Theory)</p><a href=#23-the-semat-initiative><h3 id=23-the-semat-initiative><span class=hanchor arialabel=Anchor># </span>2.3 The SEMAT Initiative</h3></a><p>Fue una inciativa iniciada por Ivar Jacobson en 2009 para lograr abstraer una serie de practicas bases (llamadas kernel) sobre las cuales se pudieran desarrollar metodos orientados al desarrollo de software basados en la disciplina de la ingenieria.</p><p>Los principales problemas que busca atacar son:</p><ul><li>Adaptarse a los problemas de nuestra industria (cambio de requerimientos, de gente, de tecnologias)</li><li>Formar un conjunto de practicas base llamado kernel que sea altamente extensible.</li><li>Apoyado por gente con relevancia en la industria, empresas, universidades, etc.</li></ul><a href=#24-essence-the-omg-standard><h3 id=24-essence-the-omg-standard><span class=hanchor arialabel=Anchor># </span>2.4 Essence: The OMG Standard</h3></a><p>Una vez fueron establecidas como acuerdo todas estas practicas, se busco que fueran altamente adoptadas por todos los desarrolladores del mundo. Para conseguir esto se busco una estandarizacion y en este caso se opto por la OMG.</p><p>La OMG acepto la iniciativa de SEMAT y a todo su conjunto de practicas, consejos y terminos le denomino &ldquo;Essencia&rdquo;.</p><a href=#resumen---software-engineering-methods-and-practices><h2 id=resumen---software-engineering-methods-and-practices><span class=hanchor arialabel=Anchor># </span>Resumen - Software Engineering Methods and Practices</h2></a><p>Se busca introducir un poco de historia sobre los metodos y practicas que se han llevado acabo en los ultimos aÃ±os de la Ingenieria del Software. Esto con el fin de justificar la creacion del conjunto de practicas, conceptos e ideas propuestos por el SEMAT en 2009 (Estandarizado por la OMG como &ldquo;escencia&rdquo; en el 2014) de la cual hablarÃ¡ el resto del libro.</p><p><strong>Metodo</strong>. conjunto de tareas que se deben realizar para lograr conseguir el desarrollo de un software.</p><p><strong>Practicas</strong>. conjunto de recomendaciones enfocadas a un aspecto de cualquier metodo de desarrollo.</p><a href=#ciclo-de-vida><h3 id=ciclo-de-vida><span class=hanchor arialabel=Anchor># </span>Ciclo de Vida</h3></a><p>Entre las practicas del ciclo de vida tenemos los metodos de: Cascada e Iterativas.</p><p>El ciclo de vida en cascada sirvio para dar guia y salir de la crisis del software, concebio las primeras ideas de como se tenia que hacer un ciclo de desarrollo, sin embargo no tomo en cuenta el contexto de nuestra industria, en el cual todo cambia y te piden que implementes nuevas funcionalidades, que mantengas, que cambies.</p><p>Fallo al hacerse un estandar debido a que no supo adaptarse a la industria, sin embargo logro su objetivo de introducir un poco de orden en el caos que habia en el mundo de desarrollo</p><p>El ciclo de vida iterativo concibe que no se tiene que realizar una gran casacada si no que se tiene que ir haciendo por ciclos, se requisita un poco, se diseÃ±a un poco, se programa un poco, se prueba un poco y se despliega para recibir feedback y volver a empezar.</p><p>Hoy en dia un ciclo de vida como este es el que se sigue empleando debido a que se adapta a nuestra industria, sin embargo, el problema que enfrentamos esque no hay un conjunto de estandares para referirse a los terminos comunes entre distintos metodos.</p><a href=#tecnicas><h3 id=tecnicas><span class=hanchor arialabel=Anchor># </span>Tecnicas</h3></a><p>Entre las practicas tecnicas tenemos dos formas: Estructuradas, Componentes</p><p>Los metodos estructurados se basan en la programacion estructural, en la cual se separan los datos de las funciones y se perciben como conjuntos separados en el cual cualquier dato puede interactuar con cualquier funcion y viceversa. Uno de los metodos mas populares fue el SADT (Tecnica de Analisis y DiseÃ±o Estructurado)</p><p>Se desecho debido a que surgieron grandes proyectos de ella pero muchisimos fallaban y tenian problemas, principalmente de matenibilidad (Creaba codigo que era dificil de leer, dificil de escalar, dificil de cambiar y no se podia probar).</p><p>Los metodos en componentes se basan en la programacion orientada a objetos, en la cual se perciben a datos y funciones como un modulo y estos modulos interactuan entre si mediante interfaces publicas. Aqui en vez de permitir que existieran muchos metodos de desarrollo se busco una estandarizacion y se creo UML y RUP.</p><p>No se ha desechado todavia, solo se dejo en el pasado UML y RUP por lo fuerte que era respecto a como se tenian que hacer las cosas, siempre como ellos decian.</p><a href=#agiles><h3 id=agiles><span class=hanchor arialabel=Anchor># </span>Agiles</h3></a><p>El conjunto de practicas mas utilizado hoy en dia son las agiles, se basa en las ideas de desarrollo iterativas, usualmente una escritura basada en componentes e incorpora practicas mas alla de solo el desarrollo. Practicas humanas para permitir un buen flujo de trabajo mediante reuniones, backlog, pair programming, etc. Practicas tecnicas permitiendo elegir lenguajes comodos para todo el equipo, con buen hardware. Practicas de codigo como el TDD, BDD, DDD, etc. Ademas de esto simplifica todo lo que se ha aprendido a lo largo de la historia y lo conjunta con un desarrollo por prototipos.</p><a href=#escencia-y-semat><h3 id=escencia-y-semat><span class=hanchor arialabel=Anchor># </span>Escencia y SEMAT</h3></a><p>Debido a la poca estandarizacion, el exceso de reinvencion de practicas con 1000 metodologias agiles, la perdida de tiempo, la perdida de dinero y otros capitales, con el SEMAT se busca crear un conjunto de practicas base (kernel le llaman ellos) que sirvan para que todos puedan crear sus propias variaciones de un metodo que sirva como marco de trabajo para que cada equipo pueda desarrollar software a su manera.</p><p>Fue aceptado por la OMG en 2014 y fue estandarizado como &ldquo;Escencia&rdquo;. Es de lo que se hablarÃ¡ el resto del libro.</p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://jaimayal.github.io/digital-garden/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><div id=contact_buttons><footer><p>Made by Jaimayal using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, Â© 2022</p><ul><li><a href=https://jaimayal.github.io/digital-garden/>Home</a></li><li><a href=https://github.com/Jaimayal>Github</a></li></ul></footer></div></div></body></html>