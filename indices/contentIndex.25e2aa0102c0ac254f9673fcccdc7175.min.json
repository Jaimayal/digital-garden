{"/":{"title":"üå≤ Digital Garden | Jaimayal","content":"## üëâ ¬°Bienvenido a mi Jardin Digital!\nAqui se archivan todas las ideas y notas sobre lo que he aprendido a lo largo de mis estudios como universitario y autodidacta.\n## ‚úî Secciones Principales\nA continuacion las secciones principales del sitio:\n- [Mapas de Contenido](es/menu/mapas.md). Puntos de entrada para todos los temas que he aprendido. \n- [Bancos de Preguntas](es/menu/bancos.md). Almacenamiento de preguntas divididas por temas. Te permiten crear tus propios examenes o flashcard\n## üîç C√≥mo navegar\nLas notas son mantenidas de tal forma que permitan libre navegacion entre una y otra (gracias a un va√∫l de [Obsidian](https://obsidian.md/)) por tanto cuentan con conexiones para navegar entre una y otra libremente.\n#### Color\nEs posible cambiar el tema actual (oscuro o claro) utilizando los iconos de noche / dia de la barra de navegacion superior.\n\n#### B√∫squeda\nLa barra de busqueda encuentra las ideas / notas que quieras en todo el sitio. Prueba utilizando palabras clave o prefijos.\n\n#### Backlinks y Grafica\nAl pie de pagina siempre encontrara una lista de notas que referencian a la pagina en la que se encuentra en ese momento. Adicionalmente en la grafica se puede visualizar las conexiones que tiene la pagina actual con otras.\n\n","lastmodified":"2022-09-19T13:52:58.034623291Z","tags":null},"/banks/bancos":{"title":"Bancos de Preguntas","content":"\nBienvenido a los bancos de preguntas. A continuacion se enlistan divididos por temas:\n### Desarrollo Personal\n- [Advice]()\n\n### Filosofia\n- [Descartes]()\n- [Nietzche]()\n\n### Programacion\n- [JavaScript]()\n- [Java]()\n- [Spring Framework]()\n- [HTML]()\n- [CSS]()\n\n### Finanzas\n- [Personales]()\n- [Analisis]()\n","lastmodified":"2022-09-19T13:52:58.034623291Z","tags":null},"/banks/oop":{"title":"Banco de Preguntas | Programacion Orientada a Objetos","content":"###### ¬øQue es una Clase?\nUna clase es un conjunto de datos (atributos, valores) y funciones (metodos, operaciones, rutinas) que sirven como modelo (patron base) sobre el cual se podran obtener uno o mas ejemplares (objetos, instancias).\n\n###### ¬øQu√© es un Objeto?\nUn objeto es un ejemplar particular de una clase, cada objeto cuenta con sus propios datos y funciones. Adicionalmente, se le es permitido comunicarse con otros objetos mediante mensajes.\n\n###### ¬øQue es un Atributo?\nUn atributo es un dato contenido en una clase, regularmente, protegido mediante el modificador de vista privada. Esto con el fin de ocultar las estructuras que lo soportan (y por tanto, promover la abstraccion y el encapsulamiento).\n\n###### ¬øQue es el Estado de un Objeto?\nEl estado de un objeto esta formado por el conjunto de datos (atributos) y los valores respectivos para cada uno. Consultar el estado de un objeto es consultar qu√© valores tiene en sus atributos.\n\n###### ¬øQue son los Metodos?\nSon las operaciones que pueden ejecutar todos los ejemplares que surgan desde una clase (esto en caso de que formen parte de la interfaz publica). Por otro lado, tambien pueden ser submetodos creados para formar metodos mas complejos, esto en caso de ser declarados con el modificador de vista privada.\n\n###### ¬øQue es un Mensaje?\nEs la forma en la cual interactuan los objetos en la POO, ocurre entre dos objetos, el que envia el mensaje (activo) y el que lo recibe (pasivo). Esta interaccion ocurre mediante la interaccion de sus interfaces publicas.\n\n###### ¬øCu√°l es la Interfaz Publica de una clase?\n\n###### ¬øCu√°l es la implementacion de la interfaz publica?\n\n###### ¬øQu√© es un Constructor?\n\n###### ¬øCu√°ndo se llama a un Constructor?\n\n###### ¬øQu√© es el constructor Default y como es su implementacion?\n\n###### ¬øQu√© son los multiples constructores?\n\n###### ¬øQue es la sobrecarga de metodos?","lastmodified":"2022-09-19T13:52:58.034623291Z","tags":null},"/mocs/mapas":{"title":"Mapas de Contenido","content":"\nBienvenido a los Mapas de Contenido!. Aqui estan los puntos de entrada a cualquier idea / nota de este sitio.\n\n#### [MOC Programacion]()\n#### [MOC Finanzas]()\n#### [MOC Filosofia]()\n#### [MOC Desarrollo Personal]()","lastmodified":"2022-09-19T13:52:58.034623291Z","tags":null},"/notes/Analisis-y-Disenio":{"title":"Analisis y Dise√±o","content":"Es un proceso que se realiza en el [Desarrollo de Software](../Desarrollo%20de%20Software.md), su objetivo principal es reducir la complejidad de un software.\n\nLa complejidad del software incrementa debido al constante cambio en los [Requisitos](Requisitos.md).\n\nPara hacerlo aprovecha e impulsa la abstraccion, encapsulacion, modularidad y jerarquia, busca finalmente crear modulos de alta calidad, es decir, que tengan alta [Mantenibilidad](Mantenibilidad.md) (escalabilidad, calidad, reusabilidad, etc).\n\nEl dise√±o de un software se puede estudiar de dos formas:\n- Utilizando herramientas de diagramas para ver los modulos y sus interacciones mediante relaciones.\n- Viendo el mismo codigo y la interaccion de unos modulos con otros.\n\n","lastmodified":"2022-09-19T13:52:58.034623291Z","tags":null},"/notes/Atributos":{"title":"Atributos","content":"Constituyen los datos particulares de una clase, pueden estar soportados por tipos primitivos (int, char, boolean, float, double, etc) o pueden estar soportados por otras clases.\n\nEstos suelen estar ocultos mediante el uso de la vista privada para evitar errores, mejorar seguridad, hacer efectivo el encapsulamiento y abstraer para reducir la complejidad de una clase.\n\n```Java\nclass Fecha {\n\t// Lista de atributos\n\tprivate int dia;\n\tprivate int mes;\n\tprivate int anio;\n}\n```","lastmodified":"2022-09-19T13:52:58.034623291Z","tags":null},"/notes/Clase":{"title":"Clase","content":"Las clases son un concepto basico de la programacion orientada a objetos. Una clase es un molde del cual podemos instanciar (crear, generar, construir, inicializar) objetos de ese tipo en particular. Este describe las operaciones y los datos que contendran los objetos que se instancien a partir de ella.\n\nFundamentalmente una clase se compone de dos cosas:\n- Atributos. Son los datos que encapsula una clase\n- Metodos. Son las acciones que puede ejecutar una clase\n\nAdicionalmente, una clase esta compuesta por una vista publica y una vista privada. \n- La vista publica representa una interfaz con la que otros objetos pueden interactuar, es el medio por el cual existe la comunicacion en la POO.\n- La vista privada representa todo lo que una clase encapsula, que es irrelevante para el mundo exterior y que se busca proteger de cambios malintencionados, suelen ser los datos (los cuales pueden ser otras clases o primitivos).\n\nUna clase tambien esta compuesta por uno o mas constructores, que son la base para inicializar los objetos.\n- Un constructor es como un metodo especial que sirve para brindar valores iniciales a una instancia en particular.\n\nA partir de una clase pueden ser instanciados objetos, cada objeto tendra sus propios miembros privados y publicos provenientes de su clase.\n\n```Java\nclass Fecha {\n\t// Vista privada\n\tprivate int dia;\n\tprivate int mes;\n\tprivate int anio;\n\n\t// Constructor\n\tpublic Fecha(int dia, int mes, int anio) {\n\t\tthis.dia = dia;\n\t\tthis.mes = mes;\n\t\tthis.anio = anio;\n\t}\n\n\t// Vista publica\n\tpublic void imprimirFecha() {\n\t\tSystem.out.println(dia + \"/\" + mes + \"/\" + anio);\n\t}\n}\n```","lastmodified":"2022-09-19T13:52:58.034623291Z","tags":null},"/notes/Desarrollo-Profesional":{"title":"Desarrollo Profesional","content":"Ocurre cuando en el proceso de [Programacion](Programacion.md) se analiza y escribe el codigo pensando claramente en cumplir los [Requisitos](Requisitos.md), contrario al [Pseudohacking](Pseudohacking.md), en el desarrollo profesional se busca agregar unicamente el codigo que se sabe y entiende claramente lo que realiza.\n\nInspirado de: [resenia](es/reference/The%20essentials%20of%20modern%20software%20engineering%20Free%20the%20practices%20from%20the%20method%20prisons/resenia.md)\n","lastmodified":"2022-09-19T13:52:58.034623291Z","tags":null},"/notes/Desarrollo-de-Software":{"title":"Desarrollo de Software","content":"El desarrollo de Software es toda una serie de procesos que se realizan con el fin de desarrollar un software de fin a fin. El desarrollo comprende los procesos de\n- [Requisitos](Requisitos.md)\n- [Analisis y Disenio](Analisis%20y%20Disenio.md)\n- [Programacion](Programacion.md)\n- [Pruebas](Pruebas.md)\n- [Despliegue](Despliegue.md)\n\nentre otros.\n\nEste proceso hoy en dia es mejorado fuertemente agregando disciplinas de la ingenieria de modo que sea mas facil de llevar, repetible y mejorable. A este proceso se le llama [Ingenieria del Software](Ingenieria%20del%20Software.md).\n\nInspirado de: [resenia](es/reference/The%20essentials%20of%20modern%20software%20engineering%20Free%20the%20practices%20from%20the%20method%20prisons/resenia.md)","lastmodified":"2022-09-19T13:52:58.034623291Z","tags":null},"/notes/Despliegue":{"title":"Despliegue","content":"Es uno de los procesos terminales que ocurre en el ciclo de [Desarrollo de Software](../Desarrollo%20de%20Software.md), busca crear un entorno de produccion para que los usuarios finales puedan utilizar el software.\n\nNormalmente se despliega en un servidor y en multiples instancias para satisfacer la demanda de los usuarios.\n\nSe utilizan multiples tecnologias para orquestar que este proceso se desarrolle de forma adecuada.\n","lastmodified":"2022-09-19T13:52:58.034623291Z","tags":null},"/notes/Dominio-de-Negocio":{"title":"Dominio de Negocio","content":"Comprende todos esas actividades que realiza una empresa, organizacion, etc como objetivo para satisfacer necesidades (y usualmente, generar capital).\n\nCada empresa tiene un diferente dominio de negocio, y entenderlo es de vital importancia para poder aplicar bien la [Ingenieria del Software](Ingenieria%20del%20Software.md).\n\nEl dominio no solo comprende las necesidades, si no tambien, la jerga con la cual se habla en el negocio en cuestion, por tanto, entenderla es de vital importancia para comunicar un equipo de desarrollo con los [Stakeholders](Stakeholders.md), y asi poder obtener los [Requisitos](../Requisitos.md) del software.\n\nInspirado de: [resenia](es/reference/The%20essentials%20of%20modern%20software%20engineering%20Free%20the%20practices%20from%20the%20method%20prisons/resenia.md)","lastmodified":"2022-09-19T13:52:58.034623291Z","tags":null},"/notes/Estado":{"title":"Estado","content":"Se refiere a los valores que tiene el conjunto de datos que encontramos en un objeto en determinado momento. \n\nRegularmente el estado lo podemos comprobar mediante la interfaz publica especificada en la clase del objeto al que queremos consultar, imaginando que en algun lugar existe la clase fecha podriamos hacer:\n\n```Java\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tFecha fecha = new Fecha(1, 1, 2002);\n\t\t// Consulta de Estado\n\t\tfecha.imprimirFecha();\n\t}\n}\n```","lastmodified":"2022-09-19T13:52:58.034623291Z","tags":null},"/notes/Fundamentos-de-la-Programacion":{"title":"Fundamentos de la Programacion","content":"Los fundamentos de la programacion (En cualquier paradigma) son cuatro:\n- Abstraccion. Utilizar terminos, conceptos e ideas para representar un concepto de manera fundamental, ignorando lo superfluo.\n- Encapsulacion. Ocultar informacion innecesaria al exterior.\n- Modularidad. El uso de unidades separadas que mientras mejor sean estaran pocamente acopladas y seran altamente cohesivas.\n- Jerarquia. La creacion de una estructura bien definida que permita seguir el flujo de un programa.\n___","lastmodified":"2022-09-19T13:52:58.034623291Z","tags":null},"/notes/Ingenieria-del-Software":{"title":"Ingenieria del Software","content":"Es la implementacion de disciplinas y practicas de la ingenieria (Como *requierements engineering*) para mejorar el [Desarrollo de Software](../Desarrollo%20de%20Software.md).\n\nInspirado de: [resenia](es/reference/The%20essentials%20of%20modern%20software%20engineering%20Free%20the%20practices%20from%20the%20method%20prisons/resenia.md)","lastmodified":"2022-09-19T13:52:58.034623291Z","tags":null},"/notes/Interacciones-con-Objetos-en-JavaScript":{"title":"","content":"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000","lastmodified":"2022-09-19T13:52:58.034623291Z","tags":null},"/notes/Mensajes":{"title":"Mensajes","content":"Es la base sobre la cual objetos pueden interactuar con otros utilizando sus vistas publicas, es decir, sus interfaces. En ese caso, un objeto activo (El que envia el mensaje) se comunica con un objeto pasivo (El que lo recibe).\n\n```Java\nclass Pasivo {\n\tprivate int valor;\n\n\tpublic void imprimirValor() {\n\t\tSystem.out.println(valor);\n\t}\n}\n\nclass Activo {\n\tpublic static void main(String[] args) {\n\t\tPasivo pas = new Pasivo();\n\t\t// Mensaje desde this hasta pas\n\t\tpas.imprimirValor();\n\t}\n}\n```","lastmodified":"2022-09-19T13:52:58.034623291Z","tags":null},"/notes/Objeto":{"title":"Objeto","content":"Es una instancia (es decir, una ocurrencia particular) o un ejemplar concreto proveniente de una clase ya definida. \n\nEstos son creados a partir de los constructores de una clase particular y por lo tanto, cuentan con sus atributos, metodos, vista publica y privada.\n\nSi comprobamos los atributos de un objeto en particular se dice que estamos comprobando su [[es/notes/Estado]].","lastmodified":"2022-09-19T13:52:58.034623291Z","tags":null},"/notes/Orientacion-a-Objetos":{"title":"Orientacion a Objetos","content":"### Vista publica de las clases - Interfaces\nLo publico es lo que es conocido en cualquier parte del sistema. Lo privado es lo que se conoce unicamente dentro de la declaracion de una clase\n- Public\n- Private\n- Clases\n- Metodos\n- Constructores\n- Overloading metodos\n- Destructores\n\nLas interfaces son sagradas","lastmodified":"2022-09-19T13:52:58.034623291Z","tags":null},"/notes/Paradigma-Orientado-a-Objetos":{"title":"Paradigma Orientado a Objetos","content":"Es un paradigma que surge como sintesis tras la orientacion a datos y la orientacion a procesos. Tiene como objetivo dar la misma importancia tanto a datos como a procesos, utilizando el concepto de Clases y vistas.\n\nEl uso de clases mejora los aspectos basicos de la programacion (Abstraccion, Encapsulamiento, Modularidad y Jerarquia) e introduce unos nuevos para poder construir un software de mejor calidad. En especifico, agrega la Herencia y el Polimorfismo.\n\nEl uso de las vistas tambien ayuda a mejorar los fundamentos de la programacion mediante vistas publicas y privadas.","lastmodified":"2022-09-19T13:52:58.034623291Z","tags":null},"/notes/Programacion":{"title":"Programacion","content":"Es una disciplina encargada de crear una serie de instrucciones en forma de codigo, utilizando un lenguaje especializado para hablar con la maquina que le permita dar las instrucciones suficientes como para que ejecute las tareas que se le asignan.\n___","lastmodified":"2022-09-19T13:52:58.034623291Z","tags":null},"/notes/Pruebas":{"title":"Pruebas","content":"Es probablemente el proceso mas infravalorado por los estudiantes que aprenden el [Desarrollo de Software](../Desarrollo%20de%20Software.md).\n\nEs absolutamente necesario si lo que se busca es trabajar en un entorno profesional. Hacer pruebas garantiza que, aunque te vayas de la empresa, tu codigo se pueda probar y por tanto, pueda cambiarse con facilidad y no rompa nada en el proceso.\n\nUsualmente los desarrolladores escriben sus propias Pruebas Unitarias.\n","lastmodified":"2022-09-19T13:52:58.034623291Z","tags":null},"/notes/Pseudohacking":{"title":"Pseudohacking","content":"Es una practica que ocurre en la [Programacion](Programacion.md) de un software, ocurre cuando un desarrollador agrega codigo casi aleatorio con el fin de conseguir un objetivo (cumplir un requisito, regularmente) sin entender realmente lo que hace el codigo que esta agregando al Software.\n\nEsta es una practica muy da√±ina y tristemente, muy popular hoy en dia.\n\nInspirado de: [resenia](es/reference/The%20essentials%20of%20modern%20software%20engineering%20Free%20the%20practices%20from%20the%20method%20prisons/resenia.md)","lastmodified":"2022-09-19T13:52:58.034623291Z","tags":null},"/notes/Requisitos":{"title":"Requisitos","content":"Es uno de los primeros procesos en el [Desarrollo de Software](../Desarrollo%20de%20Software.md). Ocurre cuando se establece comunicacion entre los [Stakeholders](Stakeholders.md) y el equipo de desarrollo.\n\nSu objetivo principal es convertir las necesidades de los clientes en requisitos claros que puedan ser interpretados por el equipo de desarrolladores. Por tanto, es necesario tener un buen conocimiento del [Dominio de Negocio](Dominio%20de%20Negocio.md) de la empresa que busca el Software.\n\nPara realizarlo se utiliza distintas practicas, incluso traidas de la ingenieria (muchas de ellas traidas de *requirements engineering*),\n\nDebido a su constante cambio es NECESARIO hacer un buen [Analisis y Disenio](../Analisis%20y%20Disenio.md) del codigo con el que va a trabajar el equipo de desarrolladores.\n","lastmodified":"2022-09-19T13:52:58.034623291Z","tags":null},"/notes/Stakeholders":{"title":"Stakeholders","content":"Son personas las cuales guardan algun tipo de relacion con la empresa (Inversionista, due√±o, experto, etc) y que, por tanto, les interesan las decisiones que se tomen dentro de ella, debido a que estas les afectan de una u otra forma.\n\nInspirado de: [The Essentials of Modern Software Engineering](es/reference/The%20essentials%20of%20modern%20software%20engineering%20Free%20the%20practices%20from%20the%20method%20prisons/main.md)","lastmodified":"2022-09-19T13:52:58.034623291Z","tags":null},"/reference/The-essentials-of-modern-software-engineering-Free-the-practices-from-the-method-prisons/main":{"title":"The essentials of modern software engineering: Free the practices from the method prisons","content":"Libro que habla sobre las practicas y metodos creados por el SEMAT (Software Engineering Methods And Theory) con el fin de buscar una serie de practicas y consejos bases sobre las cuales construir metodologias de desarrollo agiles. Estandarizado en 2013 por la OMG como \"Essentials\", el libro entra en detalle sobre su uso, los problemas que resuelve y una aplicacion efectiva.\n\n### [Rese√±a completa + Valoracion](es/reference/The%20essentials%20of%20modern%20software%20engineering%20Free%20the%20practices%20from%20the%20method%20prisons/resenia.md)\n### [Notas + Resumen](es/reference/The%20essentials%20of%20modern%20software%20engineering%20Free%20the%20practices%20from%20the%20method%20prisons/notas.md)","lastmodified":"2022-09-19T13:52:58.034623291Z","tags":null},"/reference/The-essentials-of-modern-software-engineering-Free-the-practices-from-the-method-prisons/notas":{"title":"The essentials of modern software engineering: Free the practices from the method prisons - Notes","content":"*[Volver a la Nota Principal](es/reference/The%20essentials%20of%20modern%20software%20engineering%20Free%20the%20practices%20from%20the%20method%20prisons/main.md)*\n## 1. From Programming to Software Engineering\nEste capitulo en particular busca definir de forma clara los conceptos de programador, desarrollador de software e ingeniero de software. Nos dara sus diferencias y semejanzas para poder distinguir y transicionar de una posicion a otra.\n\n### 1.1 Beginning with Programming\n**Programacion** se considera como sinonimo de *implementacion* o *codificacion*, este proceso no incluye ningun tipo de debug, o pruebas, se limita a la escritura del codigo fuente de una aplicacion.\n\n**Desarrollo de Software** es una actividad que integra la *toma de requisitos*, el *dise√±o*, la *implementacion* (programacion), las *pruebas* y el *deployment*.\n\n**Ingenieria de Software** es unir conceptos de la disciplina de *ingenieria* con el *desarrollo de software*, de modo que se obtengan todas las ventajas de ella y se agreguen a un proceso ya establecido.\n\nPara esta parte, en la jornada de Smith el ya ha aprendido todo lo basico de programacion, desde programacion estructurada hasta programacion orientada a objetos y un par de lenguajes (Java y JavaScript).\n\n### 1.2 Programming is Not Software Engineering\nHacking y Desarrollo profesional son dos cosas muy distintas y son dos acercamientos muy distintos que podemos tener a la programacion de un software.\n\n**Desarrollo Profesional** es cuando escribes el codigo de forma que refleja tu analisis y pensamiento para resolver determinado problema, de esta manera, entiendes el codigo que acabas de escribir.\n\n**Hacking** es cuando intentas codigo casi al azar hasta lograr alcanzar el objetivo que tienes sin siquiera saber como funciona.\n\nEl Desarrollo Profesional es una parte vital de la Ingenieria del Software, adicionalmente, esta ultima tiene muchas mas actividades relacionadas que no son solo escribir codigo.\n\nPara esta parte, Smith ya ha trabajado en un proyecto con compa√±eros y se dio cuenta que programar solo forma una parte del ciclo, llego a la conclusion de que se tienen que tener unos requisitos, se llega a un consenso mediante lluvia de ideas, se desarrolla y finalmente se mantiene, algo todavia muy alejado de la realidad.\n### 1.3 From Internship to Industry\nUsualmente, en un equipo de desarrollo podemos encontra dos tipos de personas:\n- Aquellas que dictan y solicitan lo que el software debe hacer\n- Aquellas que lo codifican, prueban y entregan\n\n La comunicacion entre Managers o personas con dominio sobre el problema del que se trata (primer grupo) hablan una jerga muy particular, usualmente, esta varia de empresa a empresa debido al dominio de la misma.\n\nComo leccion, para ser un buen ingeniero de software, no solo debes conocer la forma de desarrollo de tu equipo sino tambien el dominio del problema de tu empresa.\n\nUsualmente el trabajo en una empresa no se va a tratar de escribir codigo nuevo, si no de mantener y revisar el ya existente, ademas, para asegurarse de que no rompiste nada siempre hay que realizar testing a todos los cambios que hagas.\n\nMientras mas vas avanzando en los puestos de desarrollo, mayor es la cantidad de Sr (Seniority) que se te atribuye, conforme esta crece lo hacen proporcionalmente tus responsabilidades de liderazgo y comunicacion con los Stakeholders (Empresarios, jefes, CEOs, etc).\n\nUna buena comunicacion con los Stakeholders se basa en llegar a terminos y practicas comunes de modo que permitan el flujo de trabajo de todos los miembros del equipo, basandose en unos buenos valores (en tiempo, forma y de alta calidad). Engloban cosas como revisiones, correccion de bugs, recibimiento de feedback y otras habilidades para alcanzar esas metas particulares que ambos tienen en mente.\n### 1.4 Journey into the Software Engineering Profession\nLa experiencia en la universidad solo son los fundamentos de desarrollo pero carece de los siguientes aspectos:\n- No se realiza mantenimiento al codigo\n- No se implementan nuevas caracteristicas\n- No se escala para el uso de mas usuarios\n\nIgnorando las grandes compa√±ias de tecnologia como Facebook, Amazon, Twitter, Netflix, Shopify, etc. Una compa√±ia promedio seguramente buscara tener un departamento de desarrollo para satisfacer una necesidad suya, de sus clientes o de sus usuarios finales.\n\nUn joven estudiante seguramente estara mas interesado en conocer las tecnologias, las computadoras, las redes con las que se trabaja y no tanto con el dominio (negocio) de la empresa para la que va a trabajar, por tanto, no le interesaran las practicas de desarrollo, los valores u otras cosas relacionadas.\n\nLos equipos del trabajo son la unidad minima con la que se construye un software, si es un software grande, usualmente distintos equipos trabajaran de forma sincronizada en distintas funcionalidades.\n\nPara desarrollar un software primero necesitamos los requisitos, saber que es lo que se necesita hacer y revisar con los expertos para corregir cualquier mal funcion o recibir feedback respecto a las ya existentes.\n\nHay una disciplina de la ingenieria dedicada exclusivamente a los requisitos, su interpretacion, como se obtienen y como se piensa y razona sobre ellos, su nombre es *requierements engineering*.\n\nExiste otra disciplina que conforma el **dise√±o** del software, se refiere a la calidad que se coloca en el codigo de modo que le permita ser mantenible, reusable, escalable, etc. \n\nUn dise√±o se puede estudiar de dos formas:\n- Viendo las clases, modulos, funciones, unidades del codigo en cuestion.\n- Utilizando una herramienta de diagramas que te permita modelar tu codigo.\n\n*Me parecio interesante como hace mencion del dise√±o como la disciplina en la cual se le da forma al codigo para que sea de calidad / mantenible, es decir, que sea facil de escalar, de entender, de probar, de cambiar, es como lo que nos comentaba el profesor Luis en el curso de Recurrencia en el Desarrollo de Software. Lo que se busca finalmente es REDUCIR SU COMPLEJIDAD*.\n\nNo son las unicas tareas que debe hacer un ingeniero de software, usualmente se agregan dos que son las **pruebas** y el **despliegue**.\n\nSe podria decir entonces que la Ingenieria del Software es una disciplina replicable y evolucionable, que busca convertir las necesidades de un cliente en requisitos claros, para que desarrolladores con las habilidades sociales como para comunicarse y escribir codigo de calidad (es decir, en modulos que tengan alta mantenibilidad) lo dise√±en, lo desarrollen, lo prueben, reciban feedback, lo corrigan y repitan, hasta lograr el producto deseado por los clientes, en ese momento, ocurrira el despliegue.\n\n## Resumen - From Programming to Software Engineering\nProgramar es muy diferente a desarrollar software, de hecho, la programacion es solo una actividad del desarrollo, un ciclo completo del desarrollo de Software se veria asi:\n- Disciplina de Requisitos\n- Disciplina de Analisis y Dise√±o\n- Disciplina de Programacion\n- Disciplina de Pruebas\n- Disciplina de Despliegue\n\nLa Ingenieria del Software no es mas que la integracion de discplinas de la ingenieria al proceso del desarrollo de software, esto con el fin de que sea una actividad replicable, mejorable, organizada y facil de llevar.\n\nExiste una diferencia muy clara entre **desarrollo profesional** y el **\"hacking\"**, la ultima se refiere a cuando se utiliza codigo de forma casi aleatoria sin saber lo que hace hasta lograr obtener el resultado esperado, la primera ocurre cuando analisas y escribes el codigo de forma clara, de modo que, cuando lo integres con el resto del codigo sepas que es lo que esta haciendo.\n\nEl conocimiento de la jerga que se encuentra en el dominio de la empresa para la que trabajas es fundamental para comunicarse de forma efectiva con los expertos.\n\nConforme se avanza en la industria del desarrollo del Software (Es decir, se incrementa el Seniority) las habilidades de comunicacion juegan un rol cada vez mas importante. Entre ellas podemos decir que resaltan el liderazgo de un equipo y la comunicacion con los Stakeholders (o expertos) para la toma de requisitos.\n\nLa toma de requisitos puede ocurrir de distintas formas, ya sea que se te pida copiar a otro software, que se te de un papel o una simple idea. De hecho es tan cambiante e interesante que hay una disciplina de la ingenieria dedicada a ello, *requierements engineering*.\n\nDebido a que los requisitos se encuentran en constante cambio, el dise√±o del codigo del software debe de ser muy modular, con piezas que sean altamente mantenibles (faciles de entender, reusables, probables y cambiables).\n\nLas pruebas toman un rol extremadamente importante, escribirlas garantiza que aunque tu te vayas de la empresa en un futuro tu unidad de trabajo pueda seguir siendo matenible sin problemas.\n\nEl despliegue usualmente no es llevado acabo por desarrolladores, sin embargo, puede serlo, este proceso es cuando se coloca el software en un servidor o en produccion para que los usuarios finales puedan hacer uso de el.\n\n## 2. Software Engineering Methods and Practices\nEste capitulo busca introducir a la estandarizacion de las practicas y metodos utilizados en el desarrollo de software. Principalmente se abordaran tres temas:\n- Problemas que enfrenta nuestra industria\n- Metodologias de Desarrollo en los ultimos 40 a√±os\n- Motivaciones para la esencia\n\n### 2.1 Software Engineering Challenges\nExisten retos en la industria, principalmente los podemos ver en noticias de sucesos que ocurren respecto a fallos en el Software que se encuentra detras de cosas tan importantes como sistemas de seguridad o sistemas financieros.\n\nErrores como estos pueden tratar ser prevenidos pero nunca nunca sera completamente cierto que dejaran de ocurrir o que podran ser evitados del todo.\n\n### 2.2 The Rise of Software Engineering Methods and Practices\nEsta claro que la \"Crisis del Software\" no solo ocurrio por mala programacion, principalmente porque como ya vimos, un desarrollo de software no solo ocurre con programar y ya, tiene sus requisitos, comunicacion, equipos, pruebas, etc.\n\nA traves de la historia han surgido metodos de desarrollo que han servido para cumplir distintas necesidades. A las partes comunes entre un metodo y otro se le ha estandarizado como **practicas**, estas definen la esencia de las metodologias de desarrollo.\n\nEstas practicas pueden ser de distintos tipos para el equipo (ambiente agradable, de facil codificacion, de facil colaboracion), para el cliente (buena toma de requisitos, conocimiento del dominio, conocimiento de la jerga) entre otras.\n\n#### 2.2.1 There Are Lifecycles\n*Al estar leyendo sobre la introduccion a la metodologia de cascada note una similitud con lo que estamos viendo en Informatica V. En la clase vimos el proceso de Planificar, Hacer, Verificar y Actuar, en la metodologia de cascada tenemos Requisitar, Dise√±ar, Implementar y Verificar.*\n\nHubieron dos grandes cambios en las metodologias de la industria del Software.\n\nLa primera fue la introduccion de la metodologia de cascada, esta concebia al desarrollo de software como un proceso lineal en el cual se llevaba acabo la toma de requisitos, el analisis y dise√±o, la coficiacion y las pruebas. Era muy malo seguirla a rajatabla debido a que muchas veces en un proyecto de software los requisitos desde un inicio no llegan a estar completamente claros. Por tanto, al momento de probar y darle a tus usuarios el software se denota que le falta muchisima funcionalidad, le sobran muchisimas cosas cuando parecia que estabas por terminar!\n\nLa segunda fue la introduccion de iteraciones, esta dictaba que solo se tomaban pocos requisitos, se analizaba, se programaba y se probaba, de modo que, en lapsos de tiempo mucho mas cortos se pueda recibir feedback del usuario final para saber como mejorar el producto, y asi avanzar de forma iterativa\n\nEsta ultima fue tomada por metodologias agiles y la metodologia de gestion mas popular hoy en dia es SCRUM, combinada con Agile (iteraciones) forma una potente forma de desarrollar software\n\n#### 2.2.2 There Are Technical Practices\nDesde los inicios del software, los problemas con la toma de requisitos, el analisis, las pruebas, comunicacion, manejo de proyectos y liderazgo han sido recurrentes. Sin embargo, antes estos problemas eran atacados desde la perspectiva del codigo y no se le prestaba mucha atencion a lo demas. Hoy en dia, nos enfrentamos a todos los retos de forma conjunta y constante, es por eso, que surgieron nuevas metodologias para tener un marco de trabajo sobre el cual estructurar los proyectos.\n\n##### 2.2.2.1 The Structured Methods Era\nEl desarrollo se basaba en metodologias estructuradas, esto quiere decir que se percibian las funciones por un lado y los datos por otro. Surgieron marcos de trabajo y grandes proyectos bajo esta metodologia, sin embargo, al mantenimiento y la escalabilidad del software era casi nula, eso fue lo que acabo con esta era.\n\n##### 2.2.2.2 The Component Methods Era\nEl desarrollo se basaba en metodologias por *componentes* (modulos, clases, objetos, espacios, unidades, etc) principalmente influenciado por el paradigma orientado a objetos que concebia a los datos e informacion por igual. Surgieron muchos enfoques, hasta que en 1990 se unifico el modelado creando el UML (Unified Modeling Language) y se impulso la metodologia RUP (Rational Unified Process), todas las demas murieron. \n\nEsta era culmino con la creacion de practicas mas avanzadas como las arquitecturas EA - Enterprise Architecture, SOA Service-Oriented Architecture, PLA - Product-Line Architecture. Hoy en dia las podemos ver con Web Development, Cloud Services, Mobile Development, etc.\n\n##### 2.2.2.3 The Agile Methods Era\nEl desarrollo conservo los conceptos traidos desde la era anterior, se estandarizo practicas tecnicas y humanas para crear un marco de trabajo que funcionara sobre la metodologia iterativa, integro la idea de la mejora continua (Esto lo vemos con la creacion de backlogs, refactoring, TDD, etc) para continuar mejorando el desarrollo agil.\n\n##### 2.2.2.4 There Are People Practices\nAnterior a las metodologias agiles no se le tomaba importancia al capital humano, se consideraba que eso era parte de R.H. Sin embargo, tras la llegada de Agile al mundo de desarrollo se pasaron a crear nuevas practicas (Como el pair programming, las daily standups) que se enfocaban mas en darle las herramientas a los desarrolladores para que pudieran trabajar de forma continua. Es por eso que es el paradigma mas popular hoy en dia.\n\n#### 2.2.3 Consequences\nYa vimos todos los cambios que ocurrieron entre paradigmas, ciclos de vida. los proyectos, por que scrum es popular pero hay que pensar en las consecuencias que ha traido (y probablemente traera) hacer cambios por cambiar:\n- Necesidad de nueva capacitacion. Principalmente debido al cambio de vocabulario, de ideologia, de forma de desarrollar, de metodologias, de cambios en el codigo, etc, etc.\n- Creacion de 10000 metodologias bajo la misma idea, monolitos. Cada autor busca que te cases con su \"forma definitiva de desarrollar software basada en agiles\" sin tomar en cuenta las malas ideas que tienen ni nada\n- Innovaciones incitan cambios. Que bajo cada innovacion que se haga en la industria se necesitaran cambios y dependiendo la metodologia sera de mayor o menor perdida para todos.\n\n¬øTodo esto en que concluye? En perdidas de tiempo, dinero, capital de todos los tipos, tiranias de gobierno en metodologias, etc. En una industria tan grande como el desarrollo de software esto es imperdonable. Para solucionar estos problemas esque se ha la organizacion del SEMAT (Software Engineering Method And Theory)\n\n### 2.3 The SEMAT Initiative\nFue una inciativa iniciada por Ivar Jacobson en 2009 para lograr abstraer una serie de practicas bases (llamadas kernel) sobre las cuales se pudieran desarrollar metodos orientados al desarrollo de software basados en la disciplina de la ingenieria.\n\nLos principales problemas que busca atacar son:\n- Adaptarse a los problemas de nuestra industria (cambio de requerimientos, de gente, de tecnologias)\n- Formar un conjunto de practicas base llamado kernel que sea altamente extensible.\n- Apoyado por gente con relevancia en la industria, empresas, universidades, etc.\n\n### 2.4 Essence: The OMG Standard\nUna vez fueron establecidas como acuerdo todas estas practicas, se busco que fueran altamente adoptadas por todos los desarrolladores del mundo. Para conseguir esto se busco una estandarizacion y en este caso se opto por la OMG.\n\nLa OMG acepto la iniciativa de SEMAT y a todo su conjunto de practicas, consejos y terminos le denomino \"Essencia\".\n\n## Resumen - Software Engineering Methods and Practices\nSe busca introducir un poco de historia sobre los metodos y practicas que se han llevado acabo en los ultimos a√±os de la Ingenieria del Software. Esto con el fin de justificar la creacion del conjunto de practicas, conceptos e ideas propuestos por el SEMAT en 2009 (Estandarizado por la OMG como \"escencia\" en el 2014) de la cual hablar√° el resto del libro.\n\n**Metodo**. conjunto de tareas que se deben realizar para lograr conseguir el desarrollo de un software.\n\n**Practicas**. conjunto de recomendaciones enfocadas a un aspecto de cualquier metodo de desarrollo.\n\n### Ciclo de Vida\nEntre las practicas del ciclo de vida tenemos los metodos de: Cascada e Iterativas.\n\nEl ciclo de vida en cascada sirvio para dar guia y salir de la crisis del software, concebio las primeras ideas de como se tenia que hacer un ciclo de desarrollo, sin embargo no tomo en cuenta el contexto de nuestra industria, en el cual todo cambia y te piden que implementes nuevas funcionalidades, que mantengas, que cambies. \n\nFallo al hacerse un estandar debido a que no supo adaptarse a la industria, sin embargo logro su objetivo de introducir un poco de orden en el caos que habia en el mundo de desarrollo\n\nEl ciclo de vida iterativo concibe que no se tiene que realizar una gran casacada si no que se tiene que ir haciendo por ciclos, se requisita un poco, se dise√±a un poco, se programa un poco, se prueba un poco y se despliega para recibir feedback y volver a empezar.\n\nHoy en dia un ciclo de vida como este es el que se sigue empleando debido a que se adapta a nuestra industria, sin embargo, el problema que enfrentamos esque no hay un conjunto de estandares para referirse a los terminos comunes entre distintos metodos.\n\n### Tecnicas\nEntre las practicas tecnicas tenemos dos formas: Estructuradas, Componentes\n\nLos metodos estructurados se basan en la programacion estructural, en la cual se separan los datos de las funciones y se perciben como conjuntos separados en el cual cualquier dato puede interactuar con cualquier funcion y viceversa. Uno de los metodos mas populares fue el SADT (Tecnica de Analisis y Dise√±o Estructurado)\n\nSe desecho debido a que surgieron grandes proyectos de ella pero muchisimos fallaban y tenian problemas, principalmente de matenibilidad (Creaba codigo que era dificil de leer, dificil de escalar, dificil de cambiar y no se podia probar).\n\nLos metodos en componentes se basan en la programacion orientada a objetos, en la cual se perciben a datos y funciones como un modulo y estos modulos interactuan entre si mediante interfaces publicas. Aqui en vez de permitir que existieran muchos metodos de desarrollo se busco una estandarizacion y se creo UML y RUP.\n\nNo se ha desechado todavia, solo se dejo en el pasado UML y RUP por lo fuerte que era respecto a como se tenian que hacer las cosas, siempre como ellos decian.\n\n### Agiles\nEl conjunto de practicas mas utilizado hoy en dia son las agiles, se basa en las ideas de desarrollo iterativas, usualmente una escritura basada en componentes e incorpora practicas mas alla de solo el desarrollo. Practicas humanas para permitir un buen flujo de trabajo mediante reuniones, backlog, pair programming, etc. Practicas tecnicas permitiendo elegir lenguajes comodos para todo el equipo, con buen hardware. Practicas de codigo como el TDD, BDD, DDD, etc. Ademas de esto simplifica todo lo que se ha aprendido a lo largo de la historia y lo conjunta con un desarrollo por prototipos.\n\n### Escencia y SEMAT\nDebido a la poca estandarizacion, el exceso de reinvencion de practicas con 1000 metodologias agiles, la perdida de tiempo, la perdida de dinero y otros capitales, con el SEMAT se busca crear un conjunto de practicas base (kernel le llaman ellos) que sirvan para que todos puedan crear sus propias variaciones de un metodo que sirva como marco de trabajo para que cada equipo pueda desarrollar software a su manera.\n\nFue aceptado por la OMG en 2014 y fue estandarizado como \"Escencia\". Es de lo que se hablar√° el resto del libro.","lastmodified":"2022-09-19T13:52:58.034623291Z","tags":null},"/reference/The-essentials-of-modern-software-engineering-Free-the-practices-from-the-method-prisons/resenia":{"title":"The essentials of modern software engineering: Free the practices from the method prisons - Review","content":"*[Volver a la Nota Principal](es/reference/The%20essentials%20of%20modern%20software%20engineering%20Free%20the%20practices%20from%20the%20method%20prisons/main.md)*\n\n## üå± Idea Principal\nDebido a que el Software se encuentra presente en todos los aspectos de nuestra vida, este libro da la fundacion principal para construir una metodologia agil, tambien llamada *escencia* para que puedas dirigir equipos y desarrollar software de forma efectiva.\n## üå† Consideraciones\n- **Es un libro sobre METODOLOGIAS de desarrollo**.\n- Asume conocimientos de Programacion Estructurada y Programacion Orientada a Objetos.\n- Los ejemplos se encuentran escritos en Java y JavaScript.\n- Se necesita un minimo de nociones sobre UML.\n- Se necesita un poco de conocimientos sobre otras metodologias agiles (como Disciplined Agile) para hacer un contraste.\n\n## üåå Impacto\nMe ayudo a entender el ciclo de aprendizaje por el que pasaron los autores, las practicas mas comunes en empresas reales hoy en dia y me ayudo a entender las partes que tenia que rellenar en mi conocimiento. Aprendi un poco mas sobre la historia de practicas de desarrollo.\n\nA pesar de lo anterior, **deje de leer el libro**. Mis razones son las siguientes:\n- Parece otra metodologia de desarrollo agil, sin embargo, la mayoria del material para entenderla y aplicarla se encuentra detras de un paywall, \n- No hay proyectos exitosos (o siquiera que hayan fracasado) que utilicen esta metodologia. \n- Se asemeja a RUP pero sin ser tan estricta e incorporando practicas populares agiles (como juegos).\n- Crean terminologia como \"kernel\", \"competencias\" que peca de lo que critica, tener que aprender conceptos de nuevo, gastar recursos, etc.\n\n**Recomiendo los primeros dos capitulos para entender un poco sobre como se trabaja en el mundo real utilizando diferentes metodologias de desarrollo**.\n\n## ‚úç Mejores Frases\n\u003e *Software engineering is the application of a systematic, disciplined, and quantifiable approach to the development, testing, deployment, operation, and maintenance of software systems.*\n\n## *2.5 / 5.0* ‚≠ê\n\nFinalmente, checa las üìî [Notas](es/reference/The%20essentials%20of%20modern%20software%20engineering%20Free%20the%20practices%20from%20the%20method%20prisons/notas.md) que hice sobre los aspectos relevantes del libro!","lastmodified":"2022-09-19T13:52:58.034623291Z","tags":null}}